/*
 * Generated by ooc, the Object-Oriented C compiler, by Amos Wenger, 2009
 */

// OOC dependencies
#include "String.h"


/**
 * @return the length of this string.
 */
Int __lang_String_length(String this) {
	
	return strlen(this);


}

/**
 * Compares this string to the specified object. The result is true
 * if and only if the argument is not null and is a String object
 * that represents the same sequence of characters as this object.
 * @return true if this string is equal to the argument, false
 * otherwise
 */
Bool __lang_String_equals_String(String this, String s) {
	
	Int l1 = __lang_String_length(this);
	Int l2 = __lang_String_length(s);
	if(l1 != l2) {
		return false;
	}
	if(l1 == NULL || l2 == NULL) {
		return false;
	}
	for(int i = 
		0; i <  l2; i += 1)  {
		if(this[i] != s[i]) {
			return false;
		}
	}
	return true;


}

/**
 * @return this String parsed as an Int
 */
Int __lang_String_toInt(String this) {
	
	return atoi(this);


}

/**
 * @return this String parsed as a Long
 */
Long __lang_String_toLong(String this) {
	
	return atol(this);


}

/**
 * @return this String parsed as a LLong (long long)
 */
LLong __lang_String_toLLong(String this) {
	
	return atol(this);


}

/**
 * @return this String parsed as a Double
 */
Double __lang_String_toDouble(String this) {
	
	//  Amos Wenger: Standard C atof() depends on locale: imho, it sucks 

	//  in most cases, it's a comma that's needed. 

	Int intPart = 0;
	Double floatPart = 0.0;
	Double factor = 0.1;
	Bool afterDot = false;
	Int minus = 1;
	Int start = 0;
	if(this[0] == '-') {
		minus = -1;
		start = 1;
	}
	for(int i = 
		start; i <  __lang_String_length(this); i += 1)  {
		Char c = this[i];
		if(afterDot) {
			Int add = __lang_Char_toInt(c);
			if(add == -1) {
				
				break;
				//  Ignore invalid input 

			}
			floatPart += factor  *  add;
			factor *= 0.1;
		}
		else {
			if(c == '.') {
				afterDot = true;
			}
			else {
				Int add = __lang_Char_toInt(c);
				if(add == -1) {
					
					break;
					//  Ignore invalid input 

				}
				intPart *= 10;
				intPart += add;
			}
		}
	}
	return minus  * (intPart  +  floatPart);


}

/**
 * @return true if this String is empty
 */
Bool __lang_String_isEmpty(String this) {
	
	return this == NULL || this[0] == '\0';


}

/**
 * Tests if this string starts with the specified prefix.
 */
Bool __lang_String_startsWith_String(String this, String s) {
	
	Int l1 = __lang_String_length(this);
	Int l2 = __lang_String_length(s);
	if(l1 < l2) {
		return false;
	}
	for(int i = 
		0; i <  l2; i += 1)  {
		if(this[i] != s[i]) {
			return false;
		}
	}
	return true;


}

/**
 * Tests if this string ends with the specified prefix.
 */
Bool __lang_String_endsWith_String(String this, String s) {
	
	Int l1 = __lang_String_length(this);
	Int l2 = __lang_String_length(s);
	if(l1 < l2) {
		return false;
	}Int  off = l1  - l2;
	for(int i = 
		0; i <  l1; i += 1)  {
		if(this[i  +   off] != s[i]) {
			return false;
		}
	}
	return true;


}

/**
 * @return the index within this string of the first occurrence of
 * the specified character.
 */
Int __lang_String_indexOf_Char(String this, Char c) {
	
	for(int i = 
		0; i <  __lang_String_length(this); i += 1)  {
		if(this[i] == c) {
			return i;
		}
	}
	return -1;


}

/**
 * @return the index within this string of the last occurrence of
 * the specified character.
 */
Int __lang_String_lastIndexOf_Char(String this, Char c) {
	
	for(Int i = __lang_String_length(this) -1;i >= 0;i --) {
		if(this[i] == c) {
			return i;
		}
	}
	return -1;


}
// TODO eagle2com: Add negative indexes!!! 


String __lang_String_subrange_Int_Int(String this, Int index, Int range) {
	
	Int absRange = abs(range);
	String substr = GC_malloc(absRange  +  1);
	Int min;
	Int max;
	if(range > 0) {
		min = index;
		max = index  +  range;
	}
	else if(range < 0) {
		min = index  +  range;
		max = index;
	}
	else if(index >= 0 && index < __lang_String_length(this)) {
		String s = GC_malloc(2);
		s[0] = this[index];
		s[1] = '\0';
		return s;
	}
	else {
		printf("String: out of bound exception\n");
		Int x = 0;
		x = x / x;
	}
	for(int i = 
		min; i <  max; i += 1)  {
		if(i >= 0 && i < __lang_String_length(this)) {
			substr[i  - min] = this[i];
		}
	}
	substr[absRange] = '\0';
	return substr;


}

/**
 * @return a reversed copy of this String
 */
String __lang_String_reverse(String this) {
	
	if(__lang_String_isEmpty(this)) {
		//  No empty strings, please!  

		return NULL;
	}
	Char c;
	String p;
	String q;
	q = GC_malloc(__lang_String_length(this));
	memcpy(q, this, __lang_String_length(this));
	while( * (++q));
	//  points q at '\0' terminator; 

	for(p = this;p < --q;p ++) {
		//  ignores middle character when strlen is odd 

		c =  *  p;
		 *  p =  *  q;
		 *  q = c;
	}
	return q;


}
