<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" [
<!ENTITY version "v0.2 ninja">
<!ENTITY license SYSTEM "fdl.xml">
]>
<!-- 
Follow the white rabbit.
-->
<book>
  <bookinfo>
    <title>ooc &version; Language Reference</title>

    <author>
      <firstname>Amos</firstname>

      <surname>Wenger</surname>
    </author>

    <copyright>
      <year>2009</year>

      <holder>Amos Wenger</holder>
    </copyright>

    <date>2009-06-25</date>

    <legalnotice>
      <para>Distributed under the terms of the <link linkend="fdl" os="">GNU
      Free Documentation License v1.3</link></para>
    </legalnotice>

    <abstract>
      <para>This is the reference language manual for ooc &version;. It should
      be used as a reliable reference for implementation and dispute about the
      use of the ooc programming language.</para>
    </abstract>
  </bookinfo>

  <preface>
    <title>Preface</title>

    <para>This book is adressed to several kinds of person:</para>

    <itemizedlist>
      <listitem>
        <para>Users, who wish to quickly grasp how things are done in
        ooc</para>
      </listitem>

      <listitem>
        <para>Compiler writers, who want to know what they should
        implement!</para>
      </listitem>

      <listitem>
        <para>Critics, who like to read, emit judgement, and do nothing about
        it</para>
      </listitem>
    </itemizedlist>

    <para>It is assumed, throughout the book, that you have a basic knowledge
    of programming. If you come from a C or Java programming background, you
    should feel at home.</para>

    <para>I hope you'll enjoy the read!</para>
  </preface>

  <chapter>
    <title>Variables</title>

    <section>
      <title>Types</title>

      <section>
        <title>Syntax</title>

        <para>All types should be in <literal>CamelCase</literal>, all
        variables and functions in <literal>camelCase</literal>. It is a
        significant difference from C and Java, for example. In ooc, an
        integer is declared as <literal>Int</literal>, a boolean as
        <literal>Bool</literal>, and so on.</para>

        <para>The justification for that is consistency. In Java, for example,
        primitive types are in lowercase (<literal>int</literal>,
        <literal>byte</literal>, <literal>short</literal>) and classes are in
        <literal>CamelCase</literal> (<literal>String</literal>,
        <literal>System</literal>). There is some kind of consistency in this
        model, ie. you clearly see what is low-level and high-level. However,
        ooc takes another approach of consistency. Implementation details
        shouldn't interfere with the formatting of the source code. Hence, no
        distinction is made between an <literal>Int</literal> and e.g. a
        <literal>MyClass</literal>, from a user point of view.</para>
      </section>

      <section>
        <title>Constants</title>

        <para>Constants are declared with the const keyword:</para>

        <programlisting>const Float EPSILON = 0.00001f;</programlisting>

        <para>Constants are usually implemented with
        <literal>#define</literal>s<footnote>
            <para>This may raise a concern: what about name collision? In
            practice, this is almost never a problem with ooc. The generated C
            code is always prefixed with a few underscores '_' and the package
            and source unit name. E.g. __my_app_MyUnit_CONSTANT</para>
          </footnote>, so it's really impossible to modify one.</para>
      </section>

      <section>
        <title>Types from C</title>

        <section>
          <title>Correspondance with C and Java types</title>

          <table>
            <title>Correspondance tables of types in C, Java, and ooc.</title>

            <tgroup cols="4">
              <thead>
                <row>
                  <entry>C</entry>

                  <entry>Java</entry>

                  <entry>ooc</entry>

                  <entry>Comment</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>void*</entry>

                  <entry>Object</entry>

                  <entry>Object</entry>

                  <entry>really just to get rid of the nasty pointer notation.
                  useful while waiting for generics</entry>
                </row>

                <row>
                  <entry>int</entry>

                  <entry>int</entry>

                  <entry>Int</entry>

                  <entry>often the best choice for storing numbers. use Bool
                  to store boolean values.</entry>
                </row>

                <row>
                  <entry>short</entry>

                  <entry>short</entry>

                  <entry>Short</entry>

                  <entry>of little use, really. use it when you have *huge*
                  arrays of numbers and tight memory.</entry>
                </row>

                <row>
                  <entry>char</entry>

                  <entry>char (UTF-16)</entry>

                  <entry>Char</entry>

                  <entry>use it only to store characters. for 8bit numbers,
                  see Octet</entry>
                </row>

                <row>
                  <entry>char*</entry>

                  <entry>String (class)</entry>

                  <entry>String</entry>

                  <entry>fully C-string compatible, unlike C++
                  strings.</entry>
                </row>

                <row>
                  <entry>unsigned char, uint8_t</entry>

                  <entry>byte</entry>

                  <entry>Octet</entry>

                  <entry>again, of little use. may be useful for storing e.g.
                  r, g, b components of a color</entry>
                </row>

                <row>
                  <entry>unsigned int</entry>

                  <entry>-</entry>

                  <entry>UInt</entry>

                  <entry>as in C</entry>
                </row>

                <row>
                  <entry>float</entry>

                  <entry>float</entry>

                  <entry>Float</entry>

                  <entry>as in C</entry>
                </row>

                <row>
                  <entry>double</entry>

                  <entry>-</entry>

                  <entry>Double</entry>

                  <entry>as in C</entry>
                </row>

                <row>
                  <entry>long double</entry>

                  <entry>-</entry>

                  <entry>LDouble</entry>

                  <entry>new in C99</entry>
                </row>

                <row>
                  <entry>long</entry>

                  <entry>long</entry>

                  <entry>Long</entry>

                  <entry>as in C</entry>
                </row>

                <row>
                  <entry>long long</entry>

                  <entry>-</entry>

                  <entry>LLong</entry>

                  <entry>new in C99</entry>
                </row>

                <row>
                  <entry>bool</entry>

                  <entry>boolean</entry>

                  <entry>Bool</entry>

                  <entry>uses stdbool's typedefs.</entry>
                </row>

                <row>
                  <entry>pointer to function</entry>

                  <entry>hahahaha.</entry>

                  <entry>Func</entry>

                  <entry>really points to a function with no arguments
                  returning Int. more function pointer safety should be
                  introduced with generics.</entry>
                </row>

                <row>
                  <entry>size_t</entry>

                  <entry>-</entry>

                  <entry>Size</entry>

                  <entry>the type returned by sizeof. according to the C
                  standard, it should be used to store the 'size' of things,
                  e.g. byte count for memory-related functions (memcpy,
                  memmove)</entry>
                </row>
              </tbody>
            </tgroup>
          </table>
        </section>

        <section>
          <title>Typedef (aliasing name types)</title>

          <para>Typedefs exist in ooc too. They're used as in C.</para>

          <programlisting>// This example is stupid, because it redefines the String type. It's just to show how typedefs are used.
typedef Char* String;

func main {

  String name = "princesse de slougadij";
  printf("A moins que vous n'epousiez la %s?\n", name);

}</programlisting>

          <para>Don't do funky stuff with typedef: it won't work. E.g.
          <literal>typedef struct { /* etc. */ };</literal> If want a data
          structure, <link linkend="classes">define a class</link>.</para>
        </section>

        <section>
          <title>Capitalization</title>

          <para>If you try to declare something as 'int i', you'll be greeted
          by the compiler with the error message 'Invalid type name int. Types
          must start with an upper-case letter'. In this case, you can sort it
          out by using the ooc-ish 'Int'. But sometimes you just can't, e.g.
          with GLib types, '<literal>gint</literal>',
          '<literal>guint</literal>', etc. The correct handling of these cases
          is to <literal>typedef</literal>' them to something
          capitalized.</para>

          <programlisting>include glib;

typedef guint GUInt;

func main {

  GUInt myPlatformSafeInt = 69;
  gprintf("Now GLib and the ooc compilers are happy.%d\n", myPlatformSafeInt);

}</programlisting>
        </section>

        <section>
          <title>Types that can't be resolved</title>

          <para>Although the C header parser embedded in the ooc compiler
          really tries its best, sometimes (especially with
          <literal>#define</literal>s all over the place), C types aren't
          recognized, and you have compile errors. This can be solved with the
          use of the <literal>ctype</literal> keyword.</para>
        </section>
      </section>

      <section>
        <title>Covers</title>

        <para>A cover is a set of functions added to a primitive type. For
        example, String is a typedef to char*, and it has a cover
        (<literal>lang.String</literal>), which adds functions
        <literal>length</literal>, <literal>equals</literal>,
        <literal>startsWith</literal>, etc. Covers are low-level constructs
        with a high-level syntax, which makes them very useful in
        performance-critical environments.</para>

        <programlisting>include stdio;

typedef Char* String;

cover String {

  func print {
    puts(this);
  }

}

func main {

  String s = "Hello world!";
  s.print;

}
</programlisting>

        <para>Difference between class and covers will be treated more in
        depth in <link linkend="classes">a next chapter</link>.</para>
      </section>
    </section>
  </chapter>

  <chapter>
    <title>Functions</title>

    <section>
      <title>Definition</title>

      <section>
        <title>Syntax</title>

        <para>A function is declared with the
        <literal><literal>func</literal></literal> keyword.</para>

        <programlisting>// Empty function with no args that returns nothing
func useless;

func sayHello {
  printf("Hay, world!\n");
}

func saySomethingElse(String message) {
  printf("Dummy says: %s\n", message);
}

func add(Int arg1, Int arg2) -&gt; Int {
  return arg1 + arg2;
}
</programlisting>
      </section>

      <section>
        <title>Same name, different arguments</title>

        <para>In ooc, it's possible to have several functions with the same
        name and different arguments. Which function to call is selected at
        compilation time, based on the number of arguments and their
        types.</para>

        <programlisting>func main {
  dance();
  dance("Too much of heaven/Can bring you underground");
}

func dance {
  dance("Music's got me feeling so free/Celebrate and dance so free/One more time");
}

func dance(String lyrics) {
  printf("DANCE TO THE BEAT! Sing: %s\b", lyrics);
}</programlisting>
      </section>

      <section>
        <title>The main function: entry point</title>

        <para>In ooc, the main function is automatically specified to have the
        return type 'Int'. You can declare it either without arguments, or
        with argc, argv, and envp arguments (optional).</para>

        <programlisting>import structs.Array;

/** envp is optional! it contains the environment variables, and is null-terminated */
func main(Int argc, String[] argv, String[] envp) {

  for(String arg: new Array(argc, argv)) {
    printf("Got argument %s\n", arg);
  }

  Array envs = Array.nullTerminated(envp);
  for(String env: envs) {
    printf("Got environment variable %s\n", env);
  }

}</programlisting>
      </section>
    </section>

    <section>
      <title>Calling functions</title>

      <para>Functions can be called with or without parenthesis, if the
      function has no arguments. Depending on the cases, it can be more
      readable to have explicit parenthesis, or more practical to not have
      them. <emphasis role="bold">Be warned, though, calling functions without
      parenthesis only work with functions written in ooc. It won't work with
      included C functions, because the headers files are not parsed for
      function declarations.</emphasis><footnote>
          <para>The reason for that is simple. Parsing C headers is a
          nightmare. It's already done for typedefs, for example, and there
          are still cases where it fails (e.g. SDL headers). Portable header
          files are usually filled with #defines, and it makes the ooc parser
          have a hard job understanding them. To fix that, we'd have to
          complete the ooc included C preprocessor, which would be very time
          consuming. For now, you can work around the 'unrecognized types'
          issue with the 'ctype' keyword.</para>
        </footnote><programlisting>/*
 * In this example, we use SDL functions to demonstrate that
 * you have to use parenthesis to call C functions.
 * If you were to use the SDL in a real project, it'd be better to use the SDL bindings
 */
include SDL/SDL;

func main {
  init; // Need no parenthesis !
  quit;
}

func init {
  SDL_Init(SDL_INIT_EVERYTHING);
}

func quit {
  SDL_Quit(); // We must use parenthesis, cause it's a C function
}</programlisting></para>

      <para>Calling functions without parenthesis is particularly convenient
      with getters/setters, as we will see later on.</para>
    </section>

    <section>
      <title>Callbacks and pointers</title>

      <section>
        <title>Simple case</title>

        <para>In ooc, functions are almost-first-class-citizens. You can pass
        pointer to functions around easily:</para>

        <programlisting>func main {

  call(@kotokoSpeak);

}

func kotokoSpeak {

  printf("We have a very big problem!\n");

}

func call(Func toCall) {

  toCall();

}</programlisting>
      </section>

      <section>
        <title>Pointer to member functions</title>

        <para>This case is treated in <link linkend="classes">this
        chapter</link>.</para>
      </section>
    </section>
  </chapter>

  <chapter id="classes">
    <title>Classes</title>

    <section>
      <title>Syntax</title>

      <section>
        <title>Definition</title>

        <para>Classes have member variables and member functions.</para>

        <programlisting>class Dog {

  String name;
  Int age;

  func new; // Empty constructor

  func woof {
    printf("Woof, woof!\n");
  }

}</programlisting>
      </section>

      <section>
        <title>Instanciation</title>

        <para>You can instanciate objects with the new keyword, access their
        member variables and call their member functions pretty much as in
        Java.</para>

        <programlisting>Dog dog = new Dog();</programlisting>

        <para>As with functions, you can instanciate empty constructors
        without parenthesis:</para>

        <programlisting>Dog dog = new Dog;</programlisting>

        <para>The compiler is even smart enough to figure which type to
        instanciate, after a variable declaration or a variable
        assignment:</para>

        <programlisting>Dog dog = new;</programlisting>

        <para>Not, that, unlike C++, declaring only:</para>

        <programlisting>Dog dog;</programlisting>

        <para>will make dog a dangling pointer. Every object is in fact a
        pointer to a structure. For more details about the underlying
        implementation, see <link linkend="abi">the chapter ABI</link>.</para>
      </section>

      <section>
        <title>Inheritance</title>

        <para>For now, ooc has a simple inheritance model, somewhat like Java.
        To inherit a class, use the <literal>from</literal> keyword. To
        override a function, use the <literal>override</literal> keyword, or
        define a function with the same signature. <literal>override</literal>
        has the advantage of change checking: if the signature of the
        implemented function changes, it'll yield a compile error, instead of
        compiling the wrong version silently (it has the same use as the
        <literal>@Override</literal> annotation in Java).</para>

        <programlisting>class Wheel {

  func roll {
    printf("Quelque-chose ne tourne pas rond.\n");
  }

}

class BetterWheel from Wheel {

  override roll {
    printf("Pierre qui roule n'amasse pas mousse\n");
  }

}

func main {

  Wheel w = new;
  w.roll; // prints "Quelque-chose", etc.

  BetterWheel bw = new;
  bw.roll; // prints "Pierre qui roule", etc.

  Wheel w2 = (Wheel) bw; // cast as in C/Java
  w2.roll; // prints "Pierre qui roule", etc.

}</programlisting>
      </section>

      <section>
        <title>Abstract class and functions</title>

        <para>You can declare classes as abstract. They can no longer
        instanciated, and serve as base classes for other. In abstract
        classes, you can define abstract functions, that must be implemented
        by concrete (=non-abstract) child classes. To implement an abstract
        function, use the <literal>implement</literal> keyword. It has the
        same advantage as the <literal>override</literal> keyword.</para>

        <programlisting>import structs.Array;

abstract class Singer {

  abstract func sing;

}

class Hives from Singer {

  implement sing {
    printf("Tick tick tick BOOM!\n");
  }

}

class Spiderbait from Singer {

  implement sing {
    printf("Tonight, I'm going outta my head!\n");
  }

}

func main {

  ArrayList singers = new;
  singers.add(new Hives);
  singers.add(new Spiderbait);

  for(Singer singer: singers) {
    singer.sing;
  }

}</programlisting>
      </section>

      <section>
        <title>Reflection</title>

        <para>ooc has limited support for reflection. For now, it's more of a
        proof of concept, but you can do:</para>

        <programlisting>import structs.Array;

func main {

  printType(new Array);

}

func printType(Object o) {

  printf("We got an object of type %s\n", o.class.name);

}</programlisting>

        <para>In the future, reflection should be completed with fields and
        functions listing, etc.</para>
      </section>
    </section>
  </chapter>

  <chapter>
    <title>Control structures</title>

    <section>
      <title>for loop</title>

      <section>
        <title>classic for</title>
      </section>
    </section>

    <section>
      <title></title>

      <para></para>
    </section>
  </chapter>

  <appendix>
    <title>ABI (Application Binary Interface)</title>

    <para>The ooc ABI is designed to be simple and straight-forward. Also,
    there is an official ABI so that different implementations be
    compatible.<footnote>
        <para>By different implementations, I particularly think about <ulink
        url="http://github.com/amoswenger/rock">rock, the all-new attempt to
        write an ooc compiler in the ooc language</ulink>. At the time of this
        writing, it's very young: time has been spent developing ooc's
        features that could be useful for rock, rather than rock itself. As
        always, contributors are very welcome!</para>
      </footnote></para>

    <para>Note that the ooc specification is still under heavy development, so
    it means that the ABI can change significantly from a "dot version" to
    another.</para>
  </appendix>

  <appendix id="fdl">
    &license;
  </appendix>

  <appendix>
    <title>Links</title>

    <para><ulink url="http://ooc-lang.org/">the official ooc
    website</ulink></para>

    <para><ulink url="http://github.com/amoswenger/ooc">the source git
    repository on GitHub</ulink></para>

    <para><ulink url="http://live.gnome.org/Vala">the Vala programming
    language: same spirit but tied on GLib (excellent for gtk/gnome
    apps)</ulink></para>
  </appendix>
</book>
