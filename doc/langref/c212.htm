<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Classes</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"/><LINK
REL="HOME"
TITLE="ooc v0.2 ninja Language Reference"
HREF="book1.htm"/><LINK
REL="PREVIOUS"
TITLE="Callbacks and pointers"
HREF="x202.htm"/><LINK
REL="NEXT"
TITLE="Statements"
HREF="c251.htm"/></HEAD
><BODY
CLASS="chapter"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>ooc v0.2 ninja Language Reference</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x202.htm"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="c251.htm"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"/></DIV
><DIV
CLASS="chapter"
><H1
><A
NAME="classes"
></A
>Chapter 3. Classes</H1
><DIV
CLASS="section"
><H1
CLASS="section"
><A
NAME="AEN214"
>Syntax</A
></H1
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN216"
>Definition</A
></H2
><P
>Classes have member variables and member functions.</P
><PRE
CLASS="programlisting"
>class Dog {

  String name;
  Int age;

  func new; // Empty constructor

  func woof {
    printf("Woof, woof!\n");
  }

}</PRE
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN220"
>Instanciation</A
></H2
><P
>You can instanciate objects with the new keyword, access their
        member variables and call their member functions pretty much as in
        Java.</P
><PRE
CLASS="programlisting"
>Dog dog = new Dog();</PRE
><P
>As with functions, you can instanciate empty constructors
        without parenthesis:</P
><PRE
CLASS="programlisting"
>Dog dog = new Dog;</PRE
><P
>The compiler is even smart enough to figure which type to
        instanciate, after a variable declaration or a variable
        assignment:</P
><PRE
CLASS="programlisting"
>Dog dog = new;</PRE
><P
>Not, that, unlike C++, declaring only:</P
><PRE
CLASS="programlisting"
>Dog dog;</PRE
><P
>will make dog a dangling pointer. Every object is in fact a
        pointer to a structure. For more details about the underlying
        implementation, see <A
HREF="a307.htm"
>the ABI
        appendix</A
>.</P
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN232"
>Inheritance</A
></H2
><P
>For now, ooc has a simple inheritance model, somewhat like Java.
        To inherit a class, use the <TT
CLASS="literal"
>from</TT
> keyword. To
        override a function, use the <TT
CLASS="literal"
>override</TT
> keyword, or
        define a function with the same signature. <TT
CLASS="literal"
>override</TT
>
        has the advantage of change checking: if the signature of the
        implemented function changes, it'll yield a compile error, instead of
        compiling the wrong version silently (it has the same use as the
        <TT
CLASS="literal"
>@Override</TT
> annotation in Java).</P
><PRE
CLASS="programlisting"
>class Wheel {

  func roll {
    printf("Quelque-chose ne tourne pas rond.\n");
  }

}

class BetterWheel from Wheel {

  override roll {
    printf("Pierre qui roule n'amasse pas mousse\n");
  }

}

func main {

  Wheel w = new;
  w.roll; // prints "Quelque-chose", etc.

  BetterWheel bw = new;
  bw.roll; // prints "Pierre qui roule", etc.

  Wheel w2 = (Wheel) bw; // cast as in C/Java
  w2.roll; // prints "Pierre qui roule", etc.

}</PRE
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN240"
>Abstract class and functions</A
></H2
><P
>You can declare classes as abstract. They can no longer
        instanciated, and serve as base classes for other. In abstract
        classes, you can define abstract functions, that must be implemented
        by concrete (=non-abstract) child classes. To implement an abstract
        function, use the <TT
CLASS="literal"
>implement</TT
> keyword. It has the
        same advantage as the <TT
CLASS="literal"
>override</TT
> keyword.</P
><PRE
CLASS="programlisting"
>import structs.Array;

abstract class Singer {

  abstract func sing;

}

class Hives from Singer {

  implement sing {
    printf("Tick tick tick BOOM!\n");
  }

}

class Spiderbait from Singer {

  implement sing {
    printf("Tonight, I'm going outta my head!\n");
  }

}

func main {

  ArrayList singers = new;
  singers.add(new Hives);
  singers.add(new Spiderbait);

  for(Singer singer: singers) {
    singer.sing;
  }

}</PRE
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN246"
>Reflection</A
></H2
><P
>ooc has limited support for reflection. For now, it's more of a
        proof of concept, but you can do:</P
><PRE
CLASS="programlisting"
>import structs.Array;

func main {

  printType(new Array);

}

func printType(Object o) {

  printf("We got an object of type %s\n", o.class.name);

}</PRE
><P
>In the future, reflection should be completed with fields and
        functions listing, etc.</P
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"/><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x202.htm"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.htm"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="c251.htm"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Callbacks and pointers</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Statements</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>