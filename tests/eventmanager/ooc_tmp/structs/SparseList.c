/*
 * Generated by ooc, the Object-Oriented C compiler, by Amos Wenger, 2009
 */

// OOC dependencies
#include "SparseList.h"


/**
 * A sparse list stores its data into an array, resizes it when it's too
 * small,
 */

/*
 * Definition of class structs.SparseList
 */

structs_SparseList__class structs_SparseList__classInstance;


Int __structs_SparseList_size(struct structs_SparseList*  this) {
	
	return this->size;


}

Int __structs_SparseList_capacity(struct structs_SparseList*  this) {
	
	return this->capacity;


}

Void __structs_SparseList_add_Object(struct structs_SparseList*  this, Object element) {
	
	Int slot = this->class->__getFreeSlot_Int(this, -1);
	// printf("Adding to SparseList, capacity=%d, size=%d, free slot found at %d\n", capacity, size, slot); 

	this->data[slot] = element;
	this->size ++;


}

Void __structs_SparseList_add_Int_Object(struct structs_SparseList*  this, Int index, Object element) {
	
	this->data[this->class->__getFreeSlot_Int(this, index)] = element;
	this->size ++;


}

Void __structs_SparseList_clear(struct structs_SparseList*  this) {
	
	this->size = 0;


}

Object __structs_SparseList_get_Int(struct structs_SparseList*  this, Int index) {
	
	Int slot = this->class->__indexToSlot_Int(this, index);
	if(slot == -1) {
		// printf("Trying to retrieve index #%d, slot not found, fuck you?\n", index); 

		fflush(stdout);
		Int x = 0;
		x = x / x;
	}
	return this->data[slot];


}

Int __structs_SparseList_indexOf_Object(struct structs_SparseList*  this, Object element) {
	
	if(element == NULL) {
		//  No nulls are allowed in a sparse list 

		return -1;
	}Int  counter = 0;
	for(int i = 
		0; i <  this->capacity; i += 1)  {
		if(this->data[i] == element) {
			
			break;
		}
		else if(this->data[i] != NULL) {
			
			counter ++;
		}
	}
	return  counter;


}

Int __structs_SparseList_lastIndexOf_Object(struct structs_SparseList*  this, Object element) {
	
	if(element == NULL) {
		//  No nulls are allowed in a sparse list 

		return -1;
	}Int  counter = this->size -1;
	for(Int i = this->capacity -1;i >= 0;i --) {
		if(this->data[i] == element) {
			
			break;
		}
		else if(this->data[i] != NULL) {
			
			counter --;
		}
	}
	return  counter;


}

Object __structs_SparseList_remove_Int(struct structs_SparseList*  this, Int index) {
	
	Int slot = this->class->__indexToSlot_Int(this, index);
	Object element = this->data[slot];
	this->data[slot] = NULL;
	this->size --;
	return element;


}

Bool __structs_SparseList_removeElement_Object(struct structs_SparseList*  this, Object element) {
	
	Int slot = this->class->__slotOf_Object(this, element);
	if(slot != -1) {
		this->data[slot] = NULL;
		this->size --;
		return true;
	}
	else {
		return false;
	}


}

Void __structs_SparseList_set_Int_Object(struct structs_SparseList*  this, Int index, Object element) {
	
	Int slot = this->class->__indexToSlot_Int(this, index);
	if(slot != -1) {
		this->data[slot] = element;
	}


}

/**
 * private
 */
Int __structs_SparseList_slotOf_Object(struct structs_SparseList*  this, Object element) {
	
	for(int i = 
		0; i <  this->capacity; i += 1)  {
		if(this->data[i] == element) {
			return i;
		}
	}
	return -1;


}

/**
 * private
 * Here is quick rundown of how the function works:
 * - There is a distinction between an index and a slot. Indices
 * are all the user sees. Slots are the real position of data in
 * the array. Thus, often a slot number is greater than an index
 * number, as there are holes in the data.
 * - The 'minimum' parameter is how much elements must there be before
 * the free slot returned. If you don't care where the free slot is,
 * -1 should be passed as a parameter
 */
Int __structs_SparseList_getFreeSlot_Int(struct structs_SparseList*  this, Int minimum) {
	
	if(minimum == -1) {
		//  If we don't care, start at -1 

		//  In the future, this may be randomized 

		//  to allow for *statically* faster inserts 

	}Int  freeSlot = -1;
	//  Counts the number of elements before the free slot 

	Int counter = 0;
	for(int i = 
		0; i <  this->capacity; i += 1)  {
		if(this->data[i] == NULL) {
			//  A free slot! Great! But do we have at 

			//  least 'minimum' elements before us ? 

			if(counter >= minimum) {
				//  Remember, a slot is the position in the real array 

				
				freeSlot = i;
				
				break;
			}
		}
		else {
			if(counter >= minimum && minimum != -1) {
				//  Huh oh, we reached the wanted index, and still no 

				//  free space ! We gotta grow. 

				if(this->data[this->capacity -1] != NULL) {
					this->class->__grow(this);
				}
				memmove(this->data  +  i  +  1, this->data  +  i,(this->size  - i)  *  sizeof(Object));
				
				freeSlot = i;
				
				break;
			}
			//  Stumbled upon an element, increase the counter 

			counter ++;
		}
	}
	//  No free slot found ? 

	if(freeSlot == -1) {
		//  Doesn't matter, we'll find room 

		
		freeSlot = this->capacity;
		//  Now pay the rent. 

		this->class->__grow(this);
	}
	//  Now, except if malloc went woopsie-daisy, we have at least one free slot 

	return  freeSlot;


}

/**
 * private
 */
Int __structs_SparseList_indexToSlot_Int(struct structs_SparseList*  this, Int index) {
	
	Int slot = -1;
	Int counter = 0;
	for(int i = 
		0; i <  this->capacity; i += 1)  {
		if(this->data[i] != NULL) {
			if(counter >= index) {
				slot = i;
				
				break;
			}
			counter ++;
		}
	}
	return slot;


}

/**
 * private
 */
Void __structs_SparseList_grow(struct structs_SparseList*  this) {
	
	Double temp1 =(Double) this->capacity;
	Double temp2 = temp1  *  1.1;
	Int temp3 = temp2;
	this->capacity = temp3  +  10;
	// printf("SparseList: Trying to grow temp1=%.2f, temp2=%2.f, temp3=%d, now capacity=%d\n", temp1, temp2, temp3, capacity); 

	Object * tmpData = GC_realloc(this->data, this->capacity  *  sizeof(Object));
	if(tmpData != NULL) {
		this->data = tmpData;
	}
	else {
		printf("Failed to allocate %d bytes of memory for array to grow! Exiting..\n", this->capacity  *  sizeof(Object));
		exit(1);
	}


}

/**
 * private
 */
Bool __structs_SparseList_isValidIndex_Int(struct structs_SparseList*  this, Int i) {
	
	if(i < 0) {
		printf("SparseList: Index out of bounds: index=%d < 0\n", i);
		return false;
	}
	else if(i >= this->size) {
		printf("SparseList: Index out of bounds: index=%d >= size=%d\n", i, this->size);
		return false;
	}
	return true;


}

struct structs_Iterator*  __structs_SparseList_iterator(struct structs_SparseList*  this) {
	
	return(structs_Iterator) __structs_SparseListIterator_new_SparseList(this);


}

struct structs_SparseList*  __structs_SparseList_new() {

	structs_SparseList this = GC_malloc(sizeof(struct structs_SparseList));

	if(structs_SparseList__classInstance == NULL) {
		structs_SparseList__classInstance = GC_malloc(sizeof(struct structs_SparseList__class));
		structs_SparseList__classInstance->name = "structs.SparseList";
		structs_SparseList__classInstance->simpleName = "SparseList";
	}
	this->class = structs_SparseList__classInstance;

	this->class->__iterator = (struct structs_Iterator*  (*)(struct structs_SparseList* )) &__structs_SparseList_iterator;
	this->class->__add_Object = (Void (*)(struct structs_SparseList* , Object)) &__structs_SparseList_add_Object;
	this->class->__add_Int_Object = (Void (*)(struct structs_SparseList* , Int, Object)) &__structs_SparseList_add_Int_Object;
	this->class->__addAll_List = (Void (*)(struct structs_SparseList* , struct structs_List* )) &__structs_List_addAll_List;
	this->class->__addAll_Int_List = (Void (*)(struct structs_SparseList* , Int, struct structs_List* )) &__structs_List_addAll_Int_List;
	this->class->__clear = (Void (*)(struct structs_SparseList* )) &__structs_SparseList_clear;
	this->class->__removeLast = (Bool (*)(struct structs_SparseList* )) &__structs_List_removeLast;
	this->class->__contains_Object = (Bool (*)(struct structs_SparseList* , Object)) &__structs_List_contains_Object;
	this->class->__get_Int = (Object (*)(struct structs_SparseList* , Int)) &__structs_SparseList_get_Int;
	this->class->__indexOf_Object = (Int (*)(struct structs_SparseList* , Object)) &__structs_SparseList_indexOf_Object;
	this->class->__isEmpty = (Bool (*)(struct structs_SparseList* )) &__structs_List_isEmpty;
	this->class->__lastIndexOf_Object = (Int (*)(struct structs_SparseList* , Object)) &__structs_SparseList_lastIndexOf_Object;
	this->class->__remove_Int = (Object (*)(struct structs_SparseList* , Int)) &__structs_SparseList_remove_Int;
	this->class->__removeElement_Object = (Bool (*)(struct structs_SparseList* , Object)) &__structs_SparseList_removeElement_Object;
	this->class->__set_Int_Object = (Void (*)(struct structs_SparseList* , Int, Object)) &__structs_SparseList_set_Int_Object;
	this->class->__size = (Int (*)(struct structs_SparseList* )) &__structs_SparseList_size;
	this->class->__capacity = (Int (*)(struct structs_SparseList* )) &__structs_SparseList_capacity;
	this->class->__slotOf_Object = (Int (*)(struct structs_SparseList* , Object)) &__structs_SparseList_slotOf_Object;
	this->class->__getFreeSlot_Int = (Int (*)(struct structs_SparseList* , Int)) &__structs_SparseList_getFreeSlot_Int;
	this->class->__indexToSlot_Int = (Int (*)(struct structs_SparseList* , Int)) &__structs_SparseList_indexToSlot_Int;
	this->class->__grow = (Void (*)(struct structs_SparseList* )) &__structs_SparseList_grow;
	this->class->__isValidIndex_Int = (Bool (*)(struct structs_SparseList* , Int)) &__structs_SparseList_isValidIndex_Int;
	
	Int capacity = 10;
	this->capacity = capacity;
	this->size = 0;
	this->data = GC_calloc(capacity, sizeof(Object));
	// data[0] = null; // To null out the first element is capital! 
;

	return this;


}

struct structs_SparseList*  __structs_SparseList_new_Int(Int capacity) {

	structs_SparseList this = GC_malloc(sizeof(struct structs_SparseList));

	if(structs_SparseList__classInstance == NULL) {
		structs_SparseList__classInstance = GC_malloc(sizeof(struct structs_SparseList__class));
		structs_SparseList__classInstance->name = "structs.SparseList";
		structs_SparseList__classInstance->simpleName = "SparseList";
	}
	this->class = structs_SparseList__classInstance;

	this->class->__iterator = (struct structs_Iterator*  (*)(struct structs_SparseList* )) &__structs_SparseList_iterator;
	this->class->__add_Object = (Void (*)(struct structs_SparseList* , Object)) &__structs_SparseList_add_Object;
	this->class->__add_Int_Object = (Void (*)(struct structs_SparseList* , Int, Object)) &__structs_SparseList_add_Int_Object;
	this->class->__addAll_List = (Void (*)(struct structs_SparseList* , struct structs_List* )) &__structs_List_addAll_List;
	this->class->__addAll_Int_List = (Void (*)(struct structs_SparseList* , Int, struct structs_List* )) &__structs_List_addAll_Int_List;
	this->class->__clear = (Void (*)(struct structs_SparseList* )) &__structs_SparseList_clear;
	this->class->__removeLast = (Bool (*)(struct structs_SparseList* )) &__structs_List_removeLast;
	this->class->__contains_Object = (Bool (*)(struct structs_SparseList* , Object)) &__structs_List_contains_Object;
	this->class->__get_Int = (Object (*)(struct structs_SparseList* , Int)) &__structs_SparseList_get_Int;
	this->class->__indexOf_Object = (Int (*)(struct structs_SparseList* , Object)) &__structs_SparseList_indexOf_Object;
	this->class->__isEmpty = (Bool (*)(struct structs_SparseList* )) &__structs_List_isEmpty;
	this->class->__lastIndexOf_Object = (Int (*)(struct structs_SparseList* , Object)) &__structs_SparseList_lastIndexOf_Object;
	this->class->__remove_Int = (Object (*)(struct structs_SparseList* , Int)) &__structs_SparseList_remove_Int;
	this->class->__removeElement_Object = (Bool (*)(struct structs_SparseList* , Object)) &__structs_SparseList_removeElement_Object;
	this->class->__set_Int_Object = (Void (*)(struct structs_SparseList* , Int, Object)) &__structs_SparseList_set_Int_Object;
	this->class->__size = (Int (*)(struct structs_SparseList* )) &__structs_SparseList_size;
	this->class->__capacity = (Int (*)(struct structs_SparseList* )) &__structs_SparseList_capacity;
	this->class->__slotOf_Object = (Int (*)(struct structs_SparseList* , Object)) &__structs_SparseList_slotOf_Object;
	this->class->__getFreeSlot_Int = (Int (*)(struct structs_SparseList* , Int)) &__structs_SparseList_getFreeSlot_Int;
	this->class->__indexToSlot_Int = (Int (*)(struct structs_SparseList* , Int)) &__structs_SparseList_indexToSlot_Int;
	this->class->__grow = (Void (*)(struct structs_SparseList* )) &__structs_SparseList_grow;
	this->class->__isValidIndex_Int = (Bool (*)(struct structs_SparseList* , Int)) &__structs_SparseList_isValidIndex_Int;
	
	this->capacity = capacity;
	this->size = 0;
	this->data = GC_calloc(capacity, sizeof(Object));
	// data[0] = null; // To null out the first element is capital! 


	return this;


}
/*
 * Definition of class structs.SparseListIterator
 */

structs_SparseListIterator__class structs_SparseListIterator__classInstance;


Bool __structs_SparseListIterator_hasNext(struct structs_SparseListIterator*  this) {
	
	return this->index < this->list->class->__size(this->list);


}

Object __structs_SparseListIterator_next(struct structs_SparseListIterator*  this) {
	
	while(this->list->data[this->slot] == NULL) {
		this->slot ++;
	}Object  o = this->list->data[this->slot];
	this->slot ++;
	this->index ++;
	return  o;


}

struct structs_SparseListIterator*  __structs_SparseListIterator_new_SparseList(struct structs_SparseList*  list) {

	structs_SparseListIterator this = GC_malloc(sizeof(struct structs_SparseListIterator));

	this->index = 0;
	this->slot = 0;
	if(structs_SparseListIterator__classInstance == NULL) {
		structs_SparseListIterator__classInstance = GC_malloc(sizeof(struct structs_SparseListIterator__class));
		structs_SparseListIterator__classInstance->name = "structs.SparseListIterator";
		structs_SparseListIterator__classInstance->simpleName = "SparseListIterator";
	}
	this->class = structs_SparseListIterator__classInstance;

	this->class->__hasNext = (Bool (*)(struct structs_SparseListIterator* )) &__structs_SparseListIterator_hasNext;
	this->class->__next = (Object (*)(struct structs_SparseListIterator* )) &__structs_SparseListIterator_next;
	
	this->list = list;

	return this;


}
